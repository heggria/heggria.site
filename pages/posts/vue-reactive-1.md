---
title: Vue 原理：响应式编程（一）
date: 2024-10-16T16:00:00.000+00:00
duration: 15min
---

[[toc]]

响应式编程属于编程范式的一种，在了解响应式编程之前，我们先来了解一下编程范式的概念。

# 编程范式

编程范式是一种编程风格或者编程模式，它是一种编程思想的体现，是一种解决问题的方法论。

## 命令式编程

命令式编程是非常传统的软件编程方式，命令式编程由不同的逻辑执行步骤组成，通过一步步指令的执行达到业务逻辑的推进，这种方式也称为过程式编程。命令式编程的执行过程非常符合计算机的执行步骤。C语言是命令式编程的典型代表，它更关注的是机器域底层的内存、指令计算、输入输出。在C语言中，我们经常看到大段的过程式指令、各种if/else/for等控制语句、表达式、数据变量的操作、赋值等指令，这种纯指令开发方式要求开发者对计算机的底层工作原理有非常深刻的理解，而且一个指令出现偏差往往会产生不可预知的错误。同时，命令式编程模式的运维也是难度非常高的。

## 面向对象编程

面向对象编程（OOP）是一种通过类和对象来解决问题的编程方式。OOP的主要特点是封装、继承和多态，这些特性使代码更易于重用和维护。

OOP语言如C++和Java，简化了内存管理，让开发者可以专注于业务逻辑。但在某些高性能要求的场景下，OOP可能会影响代码的运行效率。

## 声明式编程

声明式编程是一种编程方式，强调通过声明来实现业务逻辑，而不是具体的实现细节。它的重点是描述要解决的问题，而不是如何解决问题。这样可以让代码更简洁，更容易维护。

> AOP（面向切面编程）是一种编程方式，用来把一些通用的功能（如日志记录、事务管理、安全性等）从业务逻辑中分离出来。通过定义切面（Aspect），这些功能可以独立实现，使代码更清晰和模块化。

> IoC（控制反转）是一种设计原则，用来减少代码之间的耦合。通过把对象的创建和依赖关系的管理交给外部容器（如Spring），实现控制反转，使代码更灵活和可维护。

## 函数式编程

在函数式编程范式中，函数无疑是一等公民，函数式编程最具魅力或者最重要的特性就是不可变性。它的不可变性表现在函数式编程表达式的执行结果，只取决于传入函数的参数序列，不受数据状态变化的影响。

函数式编程中的Lambda在Java 8中被引入，可以看成是两个类型之间的关系：一个输入类型和一个输出类型。Lambda演算就是给Lambda表达式一个输入类型的值，它就可以得到一个输出类型的值。

这个计算过程也是函数式代码对映射的描述，因为函数式代码的抽象程度非常高，所以也意味着函数式代码有更好的复用性。

函数式编程和命令式编程相比，更加关注消息或者数据的传递，而不像命令式编程，关注的是指令控制流。共享数据的状态在多线程环境下会存在资源竞争的情况，往往我们需要把额外的精力投入到冲突地解决、数据状态的维护中。而函数的不可变性保证了数据在传递处理过程中不会被篡改，也不需要依赖外部的锁资源或者状态来维护并发。所以函数式编程在多核处理器中具有天然的并发性，可以最大化地利用物理资源实现并行处理功能。

# 响应式编程 & Vue.js

响应式编程是一种面向数据流和变化传播的编程范式。响应式编程的核心思想是：数据流的变化会自动传播到依赖的地方，从而实现数据的自动更新。响应式编程的目标是简化异步数据流的处理，提高代码的可读性和可维护性。

在面向对象编程语言中，响应式编程通常以观察者模式呈现。将响应式流模式和迭代器模式比较，其主要区别是，迭代器基于“拉”模式，而响应式流基于“推”模式。

> 在编程中，迭代器和响应式流是两种不同的数据处理方式。其主要区别在于它们的数据传递模式。迭代器基于“拉”模式，而响应式流基于“推”模式。
>
> - “拉”模式意味着消费者（即使用数据的一方）主动请求数据。迭代器提供一个接口，允许消费者通过调用 `next()` 方法逐个获取数据项。这种方式的优点是消费者可以完全控制数据的获取节奏，适用于需要逐步处理数据的场景。
> - 相反，“推”模式意味着生产者（即提供数据的一方）主动发送数据给消费者。响应式流通过订阅机制，允许消费者订阅数据流，当有新数据时，生产者会自动将数据推送给所有订阅者。这种方式的优点是可以实时处理数据更新，适用于需要响应数据变化的场景。

在命令编程范式中，开发者掌握控制流，使用迭代器遍历“数据”，使用 `hasNext()` 函数判断数据是否遍历完成，使用 `next()` 函数访问下一个元素。在响应式编程模式中，使用观察者模式，数据由消息发布者（Publisher）发布并通知订阅者（Subscriber），而这种观察者模式本身在基于事件监听机制的响应式系统架构中被广泛使用。

在 Vue.js 中，响应式编程的理念被广泛应用。Vue.js 通过其响应式系统，自动追踪组件依赖并在数据变化时更新视图。Vue.js 的核心是一个响应式数据对象，当数据发生变化时，Vue.js 会自动更新相关的 DOM。

例如，在 Vue.js 中，你可以定义一个响应式数据对象：

```ts
const app = Vue.createApp({
  data() {
    return {
      message: 'Hello, Vue!'
    }
  }
})
```

当 `message` 的值改变时，Vue.js 会自动更新绑定到 `message` 的所有视图。这种响应式系统使得开发者不需要手动操作 DOM，从而提高了开发效率和代码的可维护性。

Vue.js 的响应式系统基于观察者模式，数据变化会自动通知依赖的组件进行更新，这与响应式编程的核心思想是一致的。

## 基本设计原则

响应式编程系统的设计基于以下几个基本原则：

- **数据流的自动传播**：数据流的变化会自动传播到依赖的地方，从而实现数据的自动更新。当你在Vue组件中使用一个响应式数据对象时，如果这个对象的某个属性发生变化，所有依赖这个属性的地方（如模板中的绑定）都会自动更新。

```ts
import { reactive } from 'vue'

const state = reactive({
  count: 0
})

// 当 state.count 变化时，所有依赖 state.count 的地方都会自动更新
state.count++
```

- **数据的不可变性**：数据在传递过程中不会被篡改，保证数据的一致性和可靠性。在一些状态管理库（如Redux）中，数据的不可变性是一个核心概念。每次状态变化都会生成一个新的状态对象，而不是修改现有的状态对象。

```ts
const state = {
  count: 0
}

// 创建一个新的状态对象，而不是修改现有的状态对象
const newState = { ...state, count: state.count + 1 }
```

- **数据的推送模式**：数据的生产者主动推送数据给消费者，消费者订阅数据流，当有新数据时，生产者会自动将数据推送给所有订阅者。

- **数据的订阅机制**：消费者通过订阅数据流，实现对数据的实时处理和更新。

```ts
import { ref, watchEffect } from 'vue'

const dataStream = ref(0)

// 订阅 dataStream，实现对数据的实时处理和更新
watchEffect(() => {
  console.log('Data stream updated:', dataStream.value)
})

// 改变 dataStream 的值，触发更新
dataStream.value = 2
```

响应式编程系统的设计原则使得数据流的处理更加简单和高效，提高了代码的可读性和可维护性。

## [@vue/reactivity](https://www.npmjs.com/package/@vue/reactivity) 库设计理念

Vue 的响应式系统（@vue/reactivity）是其核心功能之一，它使得 Vue 能够自动追踪组件依赖并在数据变化时更新视图。Vue 的响应式系统基于以下几个核心概念：

- **响应式数据对象**：Vue 的响应式数据对象是通过 `reactive` 函数创建的。这个函数会将普通的 JavaScript 对象转换为响应式对象。响应式对象的特点是，当其属性发生变化时，Vue 会自动追踪这些变化，并通知所有依赖这些属性的组件进行更新。这种机制使得数据和视图之间的同步变得非常简单和高效。此外，Vue 还提供了 `watchEffect` 和 `computed` 等高级 API，帮助开发者更精细地控制响应式数据的更新逻辑。

- **依赖追踪**：依赖追踪是 Vue 响应式系统的核心部分。当组件在渲染过程中访问响应式数据对象的属性时，Vue 会记录下这些依赖关系。这样，当这些属性发生变化时，Vue 就知道哪些组件需要重新渲染。这种自动化的依赖追踪机制极大地简化了开发者的工作，因为开发者不需要手动管理依赖关系。

- **数据变化通知**：当响应式数据对象的属性发生变化时，Vue 会通知所有依赖这些属性的组件进行更新。这种通知机制确保了视图总是与数据保持同步。Vue 使用一种高效的方式来进行这种通知，以确保性能不会受到影响。

- **批量&异步更新**：为了提高性能，Vue 会对数据的变化进行批量更新。也就是说，如果在同一个事件循环中有多个数据变化，Vue 会将这些变化合并在一起，然后一次性更新视图。除此之外，Vue 还会在下一个事件循环中异步更新视图。这种异步更新机制可以避免阻塞主线程，从而保持应用的响应性。
